/**
 * generated by Xtext 2.22.0
 */
package org.xtext.example.symboleo.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import java.util.Arrays;
import java.util.HashMap;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.xtext.example.symboleo.symboleo.Atom;
import org.xtext.example.symboleo.symboleo.BasicType;
import org.xtext.example.symboleo.symboleo.CType;
import org.xtext.example.symboleo.symboleo.Declar;
import org.xtext.example.symboleo.symboleo.DomainConcept;
import org.xtext.example.symboleo.symboleo.DomainType;
import org.xtext.example.symboleo.symboleo.Enumeration;
import org.xtext.example.symboleo.symboleo.EventProp;
import org.xtext.example.symboleo.symboleo.IntConst;
import org.xtext.example.symboleo.symboleo.Interval;
import org.xtext.example.symboleo.symboleo.Junction;
import org.xtext.example.symboleo.symboleo.Model;
import org.xtext.example.symboleo.symboleo.Negation;
import org.xtext.example.symboleo.symboleo.Obligation;
import org.xtext.example.symboleo.symboleo.OntoCType;
import org.xtext.example.symboleo.symboleo.Parameter;
import org.xtext.example.symboleo.symboleo.Point;
import org.xtext.example.symboleo.symboleo.PointConst;
import org.xtext.example.symboleo.symboleo.Power;
import org.xtext.example.symboleo.symboleo.Proposition;
import org.xtext.example.symboleo.symboleo.Regular;
import org.xtext.example.symboleo.symboleo.SitName;
import org.xtext.example.symboleo.symboleo.SitProp;
import org.xtext.example.symboleo.symboleo.cEvent;
import org.xtext.example.symboleo.symboleo.cState;
import org.xtext.example.symboleo.symboleo.enumItem;
import org.xtext.example.symboleo.symboleo.oEvent;
import org.xtext.example.symboleo.symboleo.oState;
import org.xtext.example.symboleo.symboleo.pEvent;
import org.xtext.example.symboleo.symboleo.pState;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class SymboleoGenerator extends AbstractGenerator {
  public String compile(final Model model) {
    StringBuilder res = new StringBuilder();
    HashMap<String, String> superTypes = new HashMap<String, String>();
    int totParams = 0;
    int p = 1;
    res.append("## Domain\n");
    EList<DomainConcept> _domainConcepts = model.getDomainConcepts();
    for (final DomainConcept domainConcept : _domainConcepts) {
      this.compileDomainConcept(domainConcept, res, superTypes);
    }
    res.append("\n## Declarations\n");
    EList<Parameter> _parameters = model.getParameters();
    for (final Parameter param : _parameters) {
      {
        String pType = this.checkParameterType(param.getType(), superTypes);
        if (((pType.equals("ROLE") || pType.equals("DATE")) || pType.equals("ASSET"))) {
          int _tParams = totParams;
          totParams = (_tParams + 1);
        }
      }
    }
    EList<Declar> _declarations = model.getDeclarations();
    for (final Declar declaration : _declarations) {
      {
        String parentType = declaration.getType().getName();
        while (superTypes.containsKey(parentType)) {
          parentType = superTypes.get(parentType);
        }
        boolean _equals = parentType.equals("ASSET");
        if (_equals) {
          int _tParams = totParams;
          totParams = (_tParams + 1);
        }
      }
    }
    String _contractName = model.getContractName();
    String _plus = ("c(X)\t:-\tinitially(" + _contractName);
    String _plus_1 = (_plus + "(X");
    res.append(_plus_1);
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, totParams, true);
    for (final Integer i : _doubleDotLessThan) {
      res.append(",_");
    }
    res.append(")).\n\n");
    int _tParams = totParams;
    totParams = (_tParams - 1);
    EList<Parameter> _parameters_1 = model.getParameters();
    for (final Parameter param_1 : _parameters_1) {
      {
        String pType = this.checkParameterType(param_1.getType(), superTypes);
        if (((pType.equals("ROLE") || pType.equals("DATE")) || pType.equals("ASSET"))) {
          boolean _equals = pType.equals("ROLE");
          if (_equals) {
            String _name = param_1.getName();
            String _plus_2 = ("initially(bind(" + _name);
            String _plus_3 = (_plus_2 + ",X))\t:-\t");
            res.append(_plus_3);
          }
          if ((pType.equals("ASSET") || pType.equals("DATE"))) {
            String _name_1 = param_1.getName();
            String _plus_4 = (_name_1 + "(X)\t:-\t");
            res.append(_plus_4);
          }
          String _contractName_1 = model.getContractName();
          String _plus_5 = ("initially(" + _contractName_1);
          String _plus_6 = (_plus_5 + "(");
          res.append(_plus_6);
          ExclusiveRange _doubleDotLessThan_1 = new ExclusiveRange(0, p, true);
          for (final Integer i_1 : _doubleDotLessThan_1) {
            res.append("_,");
          }
          res.append("X");
          ExclusiveRange _doubleDotLessThan_2 = new ExclusiveRange(0, totParams, true);
          for (final Integer i_2 : _doubleDotLessThan_2) {
            res.append(",_");
          }
          res.append(")).\n");
          int _tParams_1 = totParams;
          totParams = (_tParams_1 - 1);
          int _p = p;
          p = (_p + 1);
        }
      }
    }
    EList<Declar> _declarations_1 = model.getDeclarations();
    for (final Declar declaration_1 : _declarations_1) {
      {
        String parentType = declaration_1.getType().getName();
        while (superTypes.containsKey(parentType)) {
          parentType = superTypes.get(parentType);
        }
        boolean _equals = parentType.equals("ASSET");
        if (_equals) {
          String _name = declaration_1.getName();
          String _plus_2 = (_name + "(X)\t:-\t");
          res.append(_plus_2);
          String _contractName_1 = model.getContractName();
          String _plus_3 = ("initially(" + _contractName_1);
          String _plus_4 = (_plus_3 + "(");
          res.append(_plus_4);
          ExclusiveRange _doubleDotLessThan_1 = new ExclusiveRange(0, p, true);
          for (final Integer i_1 : _doubleDotLessThan_1) {
            res.append("_,");
          }
          res.append("X");
          ExclusiveRange _doubleDotLessThan_2 = new ExclusiveRange(0, totParams, true);
          for (final Integer i_2 : _doubleDotLessThan_2) {
            res.append(",_");
          }
          res.append(")).\n");
          int _tParams_1 = totParams;
          totParams = (_tParams_1 - 1);
          int _p = p;
          p = (_p + 1);
        }
      }
    }
    res.append("\n\n");
    EList<Declar> _declarations_2 = model.getDeclarations();
    for (final Declar declaration_2 : _declarations_2) {
      this.compileDeclaration(declaration_2, res, superTypes);
    }
    res.append("\n## Contract\n");
    res.append("initially(form(X))\t:-\t");
    String _contractName_1 = model.getContractName();
    String _plus_2 = ("initially(" + _contractName_1);
    String _plus_3 = (_plus_2 + "(X");
    res.append(_plus_3);
    ExclusiveRange _doubleDotLessThan_1 = new ExclusiveRange(0, (p - 1), true);
    for (final Integer i_1 : _doubleDotLessThan_1) {
      res.append(",_");
    }
    res.append(")).\n");
    res.append("\n## Obligations\n");
    int _length = ((Object[])Conversions.unwrapArray(model.getObligations(), Object.class)).length;
    ExclusiveRange _doubleDotLessThan_2 = new ExclusiveRange(0, _length, true);
    for (final Integer i_2 : _doubleDotLessThan_2) {
      this.compileObligations(model.getObligations().get((i_2).intValue()), ((i_2).intValue() + 1), res);
    }
    res.append("\n## Powers\n");
    int _length_1 = ((Object[])Conversions.unwrapArray(model.getPowers(), Object.class)).length;
    ExclusiveRange _doubleDotLessThan_3 = new ExclusiveRange(0, _length_1, true);
    for (final Integer i_3 : _doubleDotLessThan_3) {
      this.compilePowers(model.getPowers().get((i_3).intValue()), ((i_3).intValue() + 1), res);
    }
    res.append("\n## Surviving Obligations\n");
    int _length_2 = ((Object[])Conversions.unwrapArray(model.getSobligations(), Object.class)).length;
    ExclusiveRange _doubleDotLessThan_4 = new ExclusiveRange(0, _length_2, true);
    for (final Integer i_4 : _doubleDotLessThan_4) {
      this.compileSObligations(model.getSobligations().get((i_4).intValue()), ((i_4).intValue() + 1), res);
    }
    return res.toString();
  }
  
  public StringBuilder compileSObligations(final Obligation obl, final int i, final StringBuilder res) {
    StringBuilder _xblockexpression = null;
    {
      res.append((("SO(X)\t:-\tSO" + Integer.valueOf(i)) + "(X).\n"));
      String _name = obl.getName();
      String _plus = ((("SO" + Integer.valueOf(i)) + "(") + _name);
      String _plus_1 = (_plus + ").\n");
      res.append(_plus_1);
      String _name_1 = obl.getName();
      String _plus_2 = ("associate(" + _name_1);
      String _plus_3 = (_plus_2 + ",cArgToCan).\n\n");
      res.append(_plus_3);
      String _role1 = obl.getRole1();
      String _plus_4 = ((("initially(debtor(X,P))\t:-\tO" + Integer.valueOf(i)) + "(X),initially(bind(") + _role1);
      String _plus_5 = (_plus_4 + ",P)).\n");
      res.append(_plus_5);
      String _role1_1 = obl.getRole1();
      String _plus_6 = ((("initially(creditor(X,P))\t:-\tO" + Integer.valueOf(i)) + "(X),initially(bind(") + _role1_1);
      String _plus_7 = (_plus_6 + ",P)).\n\n");
      res.append(_plus_7);
      this.compileAntecedent(obl.getAntecedent(), obl.getName(), res);
      this.compileTrigger(obl.getTrigger(), obl.getName(), res);
      this.compileOConsequent(obl.getConsequent(), obl.getName(), res);
      _xblockexpression = res.append("\n\n");
    }
    return _xblockexpression;
  }
  
  public void compilePowers(final Power power, final int i, final StringBuilder res) {
    res.append((("P(X)\t:-\tP" + Integer.valueOf(i)) + "(X).\n"));
    String _name = power.getName();
    String _plus = ((("P" + Integer.valueOf(i)) + "(") + _name);
    String _plus_1 = (_plus + ").\n");
    res.append(_plus_1);
    String _name_1 = power.getName();
    String _plus_2 = ("associate(" + _name_1);
    String _plus_3 = (_plus_2 + ",cArgToCan).\n\n");
    res.append(_plus_3);
    String _role1 = power.getRole1();
    String _plus_4 = ((("initially(debtor(X,P))\t:-\tP" + Integer.valueOf(i)) + "(X),initially(bind(") + _role1);
    String _plus_5 = (_plus_4 + ",P)).\n");
    res.append(_plus_5);
    String _role1_1 = power.getRole1();
    String _plus_6 = ((("initially(creditor(X,P))\t:-\tP" + Integer.valueOf(i)) + "(X),initially(bind(") + _role1_1);
    String _plus_7 = (_plus_6 + ",P)).\n\n");
    res.append(_plus_7);
    this.compileAntecedent(power.getAntecedent(), power.getName(), res);
    this.compileTrigger(power.getTrigger(), power.getName(), res);
  }
  
  protected String _checkParameterType(final DomainType dType, final HashMap<String, String> superTypes) {
    String parentType = dType.getSuperType().getName();
    while (superTypes.containsKey(parentType)) {
      parentType = superTypes.get(parentType);
    }
    return parentType;
  }
  
  protected String _checkParameterType(final BasicType bType, final HashMap<String, String> superTypes) {
    return bType.getName();
  }
  
  /**
   * Generates prolog code for a declaration
   */
  public StringBuilder compileDeclaration(final Declar declaration, final StringBuilder res, final HashMap<String, String> superTypes) {
    StringBuilder _xblockexpression = null;
    {
      String parentType = declaration.getType().getName();
      while (superTypes.containsKey(parentType)) {
        parentType = superTypes.get(parentType);
      }
      StringBuilder _xifexpression = null;
      boolean _equals = parentType.equals("EVENT");
      if (_equals) {
        StringBuilder _xblockexpression_1 = null;
        {
          String _name = declaration.getName();
          String _plus = (_name + "(E)\t:-\t");
          res.append(_plus);
          res.append("happens(E,T),");
          String _name_1 = declaration.getName();
          String _plus_1 = ("holds_at(type(E," + _name_1);
          String _plus_2 = (_plus_1 + "),T),");
          res.append(_plus_2);
          int _length = ((Object[])Conversions.unwrapArray(declaration.getAttributes(), Object.class)).length;
          ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _length, true);
          for (final Integer i : _doubleDotLessThan) {
            {
              boolean _equals_1 = declaration.getAttributes().get((i).intValue()).getAttr().equals("from");
              if (_equals_1) {
                String _name_2 = declaration.getAttributes().get((i).intValue()).getParam().getName();
                String _plus_3 = ("within(E,performer(O," + _name_2);
                String _plus_4 = (_plus_3 + ")),");
                res.append(_plus_4);
              }
              boolean _equals_2 = declaration.getAttributes().get((i).intValue()).getAttr().equals("to");
              if (_equals_2) {
                String _name_3 = declaration.getAttributes().get((i).intValue()).getParam().getName();
                String _plus_5 = ("within(E,rightHolder(O," + _name_3);
                String _plus_6 = (_plus_5 + ")),");
                res.append(_plus_6);
              }
              String _attr = declaration.getAttributes().get((i).intValue()).getAttr();
              String _plus_7 = ("holds_at(" + _attr);
              String _plus_8 = (_plus_7 + "(E,");
              String _name_4 = declaration.getAttributes().get((i).intValue()).getParam().getName();
              String _plus_9 = (_plus_8 + _name_4);
              String _plus_10 = (_plus_9 + "),T)");
              res.append(_plus_10);
              int _length_1 = ((Object[])Conversions.unwrapArray(declaration.getAttributes(), Object.class)).length;
              int _minus = (_length_1 - 1);
              boolean _lessThan = ((i).intValue() < _minus);
              if (_lessThan) {
                res.append(",");
              }
            }
          }
          _xblockexpression_1 = res.append(".\n");
        }
        _xifexpression = _xblockexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  /**
   * Generates prolog code for a regular domain concept
   */
  protected Object _compileDomainConcept(final Regular domainConcept, final StringBuilder res, final HashMap<String, String> superTypes) {
    return this.compileCType(domainConcept.getConceptType(), domainConcept.getName(), res, superTypes);
  }
  
  /**
   * compiles domain concept if its type is another domain concept
   */
  protected String _compileCType(final DomainType dType, final String dName, final StringBuilder res, final HashMap<String, String> superTypes) {
    String _xblockexpression = null;
    {
      String _name = dType.getSuperType().getName();
      String _plus = (_name + "(X)\t:-\t");
      String _plus_1 = (_plus + dName);
      String _plus_2 = (_plus_1 + "(X).\n");
      res.append(_plus_2);
      _xblockexpression = superTypes.put(dName, dType.getSuperType().getName());
    }
    return _xblockexpression;
  }
  
  /**
   * compiles domain concept if its type is a basic type
   */
  protected String _compileCType(final BasicType bType, final String dName, final StringBuilder res, final HashMap<String, String> superTypes) {
    String _xblockexpression = null;
    {
      String _name = bType.getName();
      String _plus = (_name + "(");
      String _plus_1 = (_plus + dName);
      String _plus_2 = (_plus_1 + ").\n");
      res.append(_plus_2);
      _xblockexpression = superTypes.put(dName, bType.getName());
    }
    return _xblockexpression;
  }
  
  /**
   * compiles domain concept if its type is an ontoctype
   */
  protected String _compileCType(final OntoCType oType, final String dName, final StringBuilder res, final HashMap<String, String> superTypes) {
    String _xblockexpression = null;
    {
      boolean _equals = oType.getName().equals("ROLE");
      if (_equals) {
        res.append((("ROLE(" + dName) + ").\n"));
      } else {
        String _name = oType.getName();
        String _plus = (_name + "(X)\t:-\t");
        String _plus_1 = (_plus + dName);
        String _plus_2 = (_plus_1 + "(X).\n");
        res.append(_plus_2);
      }
      _xblockexpression = superTypes.put(dName, oType.getName());
    }
    return _xblockexpression;
  }
  
  /**
   * Generates prolog code for an enumeration domain concept
   */
  protected Object _compileDomainConcept(final Enumeration domainConcept, final StringBuilder res, final HashMap<String, String> superTypes) {
    StringBuilder _xblockexpression = null;
    {
      EList<enumItem> _enumerationItems = domainConcept.getEnumerationItems();
      for (final enumItem value : _enumerationItems) {
        String _name = domainConcept.getName();
        String _plus = (_name + "(");
        String _name_1 = value.getName();
        String _plus_1 = (_plus + _name_1);
        String _plus_2 = (_plus_1 + ").\n");
        res.append(_plus_2);
      }
      _xblockexpression = res.append("\n");
    }
    return _xblockexpression;
  }
  
  public StringBuilder compileObligations(final Obligation obl, final int i, final StringBuilder res) {
    StringBuilder _xblockexpression = null;
    {
      res.append((("O(X)\t:-\tO" + Integer.valueOf(i)) + "(X).\n"));
      String _name = obl.getName();
      String _plus = ((("O" + Integer.valueOf(i)) + "(") + _name);
      String _plus_1 = (_plus + ").\n");
      res.append(_plus_1);
      String _name_1 = obl.getName();
      String _plus_2 = ("associate(" + _name_1);
      String _plus_3 = (_plus_2 + ",cArgToCan).\n\n");
      res.append(_plus_3);
      String _role1 = obl.getRole1();
      String _plus_4 = ((("initially(debtor(X,P))\t:-\tO" + Integer.valueOf(i)) + "(X),initially(bind(") + _role1);
      String _plus_5 = (_plus_4 + ",P)).\n");
      res.append(_plus_5);
      String _role1_1 = obl.getRole1();
      String _plus_6 = ((("initially(creditor(X,P))\t:-\tO" + Integer.valueOf(i)) + "(X),initially(bind(") + _role1_1);
      String _plus_7 = (_plus_6 + ",P)).\n\n");
      res.append(_plus_7);
      this.compileAntecedent(obl.getAntecedent(), obl.getName(), res);
      this.compileTrigger(obl.getTrigger(), obl.getName(), res);
      this.compileOConsequent(obl.getConsequent(), obl.getName(), res);
      _xblockexpression = res.append("\n\n");
    }
    return _xblockexpression;
  }
  
  public StringBuilder compileAntecedent(final Proposition prop, final String oblName, final StringBuilder res) {
    StringBuilder _xblockexpression = null;
    {
      StringBuilder ant = new StringBuilder();
      EList<Junction> _junctions = prop.getJunctions();
      for (final Junction junction : _junctions) {
        {
          ant.append((("ant(" + oblName) + ")\t:-\t"));
          this.obligationCompileAnds(junction, ant, 0);
          ant.append(".\n");
        }
      }
      _xblockexpression = res.append(ant.toString());
    }
    return _xblockexpression;
  }
  
  public StringBuilder compileOConsequent(final Proposition prop, final String oblName, final StringBuilder res) {
    StringBuilder _xblockexpression = null;
    {
      StringBuilder cons = new StringBuilder();
      EList<Junction> _junctions = prop.getJunctions();
      for (final Junction junction : _junctions) {
        {
          cons.append((("initiates(E0, cons(" + oblName) + "))\t:\t"));
          this.obligationCompileAnds(junction, cons, 0);
          cons.append(".\n");
        }
      }
      _xblockexpression = res.append(cons.toString());
    }
    return _xblockexpression;
  }
  
  public void compileTrigger(final Proposition trigger, final String oblName, final StringBuilder res) {
    if ((trigger == null)) {
      res.append((("initiates(E0,trigger(" + oblName) + "))\t:-\thappens(E0,_),initiates(E0,inEffect(cArgToCan)).\n"));
      return;
    }
    StringBuilder trig = new StringBuilder();
    EList<Junction> _junctions = trigger.getJunctions();
    for (final Junction junction : _junctions) {
      {
        trig.append((("initiates(E0,trigger(" + oblName) + "))\t:-\t"));
        this.obligationCompileAnds(junction, trig, 0);
        trig.append(".\n");
      }
    }
    res.append(trig.toString());
  }
  
  public void obligationCompileAnds(final Junction junc, final StringBuilder res, final int d) {
    int x = 0;
    EList<Negation> _negativeAtoms = junc.getNegativeAtoms();
    for (final Negation atom : _negativeAtoms) {
      {
        this.obligationCompileNegs(atom, res, d);
        int _length = ((Object[])Conversions.unwrapArray(junc.getNegativeAtoms(), Object.class)).length;
        int _minus = (_length - 1);
        boolean _lessThan = (x < _minus);
        if (_lessThan) {
          res.append(",");
          int _x = x;
          x = (_x + 1);
        }
      }
    }
  }
  
  public StringBuilder obligationCompileNegs(final Negation atom, final StringBuilder res, final int d) {
    StringBuilder _xifexpression = null;
    boolean _isNegated = atom.isNegated();
    if (_isNegated) {
      StringBuilder _xblockexpression = null;
      {
        res.append("\\+(");
        this.obligationCompileAtom(atom.getAtomicExpression(), res, d);
        _xblockexpression = res.append(")");
      }
      _xifexpression = _xblockexpression;
    } else {
      _xifexpression = this.obligationCompileAtom(atom.getAtomicExpression(), res, d);
    }
    return _xifexpression;
  }
  
  public StringBuilder obligationCompileAtom(final Atom atom, final StringBuilder res, final int d) {
    StringBuilder _xblockexpression = null;
    {
      String _bool = atom.getBool();
      boolean _equals = Objects.equal(_bool, "TRUE");
      if (_equals) {
        res.append("TRUE");
      }
      String _bool_1 = atom.getBool();
      boolean _equals_1 = Objects.equal(_bool_1, "FALSE");
      if (_equals_1) {
        res.append("FALSE");
      }
      EventProp _eventProposition = atom.getEventProposition();
      boolean _notEquals = (!Objects.equal(_eventProposition, null));
      if (_notEquals) {
        this.obligationCompileEventProp(atom.getEventProposition(), res, d);
      }
      SitProp _situationProposition = atom.getSituationProposition();
      boolean _notEquals_1 = (!Objects.equal(_situationProposition, null));
      if (_notEquals_1) {
        this.obligationCompileSituationProp(atom.getSituationProposition(), res, d);
      }
      StringBuilder _xifexpression = null;
      if (((!Objects.equal(atom.getPoint(), null)) && (!Objects.equal(atom.getInterval(), null)))) {
        _xifexpression = this.obligationCompileWithin(atom.getPoint(), atom.getInterval(), res, d);
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public StringBuilder obligationCompileWithin(final Point point, final Interval interval, final StringBuilder res, final int d) {
    StringBuilder _xblockexpression = null;
    {
      this.compilePoint(point, res, d);
      res.append(",");
      _xblockexpression = this.compileInterval(interval, res, (d + 1));
    }
    return _xblockexpression;
  }
  
  public StringBuilder obligationCompileEventProp(final EventProp eProp, final StringBuilder res, final int d) {
    StringBuilder _xblockexpression = null;
    {
      this.compilePoint(eProp.getPoint(), res, d);
      res.append(",");
      StringBuilder _xifexpression = null;
      String _eventName = eProp.getEventName();
      boolean _notEquals = (!Objects.equal(_eventName, null));
      if (_notEquals) {
        String _eventName_1 = eProp.getEventName();
        String _plus = (_eventName_1 + "(E");
        String _plus_1 = (_plus + Integer.valueOf(d));
        String _plus_2 = (_plus_1 + ")");
        _xifexpression = res.append(_plus_2);
      } else {
        StringBuilder _xblockexpression_1 = null;
        {
          oEvent _oEventName = eProp.getOEventName();
          boolean _notEquals_1 = (!Objects.equal(_oEventName, null));
          if (_notEquals_1) {
            this.compileOEvent(eProp.getOEventName(), res, d);
          }
          cEvent _cEventName = eProp.getCEventName();
          boolean _notEquals_2 = (!Objects.equal(_cEventName, null));
          if (_notEquals_2) {
            this.compileCEvent(eProp.getCEventName(), res, d);
          }
          StringBuilder _xifexpression_1 = null;
          pEvent _pEventName = eProp.getPEventName();
          boolean _notEquals_3 = (!Objects.equal(_pEventName, null));
          if (_notEquals_3) {
            _xifexpression_1 = this.compilePEvent(eProp.getPEventName(), res, d);
          }
          _xblockexpression_1 = _xifexpression_1;
        }
        _xifexpression = _xblockexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public StringBuilder obligationCompileSituationProp(final SitProp sProp, final StringBuilder res, final int d) {
    StringBuilder _xblockexpression = null;
    {
      this.compileInterval(sProp.getInterval(), res, d);
      res.append(",");
      StringBuilder _xifexpression = null;
      String _situationName = sProp.getSituationName();
      boolean _notEquals = (!Objects.equal(_situationName, null));
      if (_notEquals) {
        String _situationName_1 = sProp.getSituationName();
        String _plus = (_situationName_1 + "(E");
        String _plus_1 = (_plus + Integer.valueOf(d));
        String _plus_2 = (_plus_1 + ")");
        _xifexpression = res.append(_plus_2);
      } else {
        StringBuilder _xblockexpression_1 = null;
        {
          res.append((("initiates(E" + Integer.valueOf(d)) + ","));
          oState _oSituationName = sProp.getOSituationName();
          boolean _notEquals_1 = (!Objects.equal(_oSituationName, null));
          if (_notEquals_1) {
            this.compileOState(sProp.getOSituationName(), res);
          }
          cState _cSituationName = sProp.getCSituationName();
          boolean _notEquals_2 = (!Objects.equal(_cSituationName, null));
          if (_notEquals_2) {
            this.compileCState(sProp.getCSituationName(), res);
          }
          pState _pSituationName = sProp.getPSituationName();
          boolean _notEquals_3 = (!Objects.equal(_pSituationName, null));
          if (_notEquals_3) {
            this.compilePState(sProp.getPSituationName(), res);
          }
          String _situationName_2 = sProp.getSituationName();
          boolean _notEquals_4 = (!Objects.equal(_situationName_2, null));
          if (_notEquals_4) {
            String _situationName_3 = sProp.getSituationName();
            String _plus_3 = (_situationName_3 + "(X)");
            res.append(_plus_3);
          }
          _xblockexpression_1 = res.append(")");
        }
        _xifexpression = _xblockexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public StringBuilder compilePoint(final Point point, final StringBuilder res, final int d) {
    StringBuilder _xifexpression = null;
    String _unnamed = point.getUnnamed();
    boolean _notEquals = (!Objects.equal(_unnamed, null));
    if (_notEquals) {
      _xifexpression = res.append((((("happens(E" + Integer.valueOf(d)) + ",T") + Integer.valueOf(d)) + ")"));
    } else {
      StringBuilder _xifexpression_1 = null;
      String _tempOp = point.getTempOp();
      boolean _notEquals_1 = (!Objects.equal(_tempOp, null));
      if (_notEquals_1) {
        StringBuilder _xblockexpression = null;
        {
          res.append((((("happens(E" + Integer.valueOf(d)) + ",T") + Integer.valueOf(d)) + "),"));
          res.append((((("happens(E" + Integer.valueOf((d + 1))) + ",T") + Integer.valueOf((d + 1))) + "),"));
          this.compileEvent(point.getEventName(), res, (d + 1));
          res.append(",");
          res.append(("T" + Integer.valueOf(d)));
          boolean _equals = point.getTempOp().equals("BEFORE");
          if (_equals) {
            res.append("-");
          } else {
            res.append("+");
          }
          int _type = point.getPointConst().getType();
          String _plus = (Integer.valueOf(_type) + "=T");
          String _plus_1 = (_plus + Integer.valueOf((d + 1)));
          _xblockexpression = res.append(_plus_1);
        }
        _xifexpression_1 = _xblockexpression;
      } else {
        StringBuilder _xifexpression_2 = null;
        PointConst _pointConst = point.getPointConst();
        boolean _notEquals_2 = (!Objects.equal(_pointConst, null));
        if (_notEquals_2) {
          int _type = point.getPointConst().getType();
          String _plus = ((("happens(E" + Integer.valueOf(d)) + ",") + Integer.valueOf(_type));
          String _plus_1 = (_plus + ")");
          _xifexpression_2 = res.append(_plus_1);
        } else {
          StringBuilder _xblockexpression_1 = null;
          {
            res.append((((("happens(E" + Integer.valueOf(d)) + ",T") + Integer.valueOf(d)) + "),"));
            _xblockexpression_1 = this.compileEvent(point.getEventName(), res, d);
          }
          _xifexpression_2 = _xblockexpression_1;
        }
        _xifexpression_1 = _xifexpression_2;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  public StringBuilder compileEvent(final SitName event, final StringBuilder res, final int d) {
    StringBuilder _xblockexpression = null;
    {
      oEvent _oEvent = event.getOEvent();
      boolean _notEquals = (!Objects.equal(_oEvent, null));
      if (_notEquals) {
        this.compileOEvent(event.getOEvent(), res, d);
      }
      cEvent _cEvent = event.getCEvent();
      boolean _notEquals_1 = (!Objects.equal(_cEvent, null));
      if (_notEquals_1) {
        this.compileCEvent(event.getCEvent(), res, d);
      }
      pEvent _pEvent = event.getPEvent();
      boolean _notEquals_2 = (!Objects.equal(_pEvent, null));
      if (_notEquals_2) {
        this.compilePEvent(event.getPEvent(), res, d);
      }
      StringBuilder _xifexpression = null;
      String _sitName = event.getSitName();
      boolean _notEquals_3 = (!Objects.equal(_sitName, null));
      if (_notEquals_3) {
        String _sitName_1 = event.getSitName();
        String _plus = (_sitName_1 + "(E");
        String _plus_1 = (_plus + Integer.valueOf(d));
        String _plus_2 = (_plus_1 + ")");
        _xifexpression = res.append(_plus_2);
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public StringBuilder compileOEvent(final oEvent event, final StringBuilder res, final int d) {
    StringBuilder _xblockexpression = null;
    {
      res.append((("initiates(E" + Integer.valueOf(d)) + ","));
      String _oblEvent = event.getOblEvent();
      if (_oblEvent != null) {
        switch (_oblEvent) {
          case "oTRIGGERED":
            String _oblName = event.getOblName();
            String _plus = ("trigger(" + _oblName);
            String _plus_1 = (_plus + ")");
            res.append(_plus_1);
            break;
          case "oACTIVATED":
            String _oblName_1 = event.getOblName();
            String _plus_2 = ("activate(" + _oblName_1);
            String _plus_3 = (_plus_2 + ")");
            res.append(_plus_3);
            break;
          case "oSUSPENDED":
            String _oblName_2 = event.getOblName();
            String _plus_4 = ("suspend(" + _oblName_2);
            String _plus_5 = (_plus_4 + ")");
            res.append(_plus_5);
            break;
          case "oRESUMED":
            String _oblName_3 = event.getOblName();
            String _plus_6 = ("resume(" + _oblName_3);
            String _plus_7 = (_plus_6 + ")");
            res.append(_plus_7);
            break;
          case "oDISCHARGED":
            String _oblName_4 = event.getOblName();
            String _plus_8 = ("discharge(" + _oblName_4);
            String _plus_9 = (_plus_8 + ")");
            res.append(_plus_9);
            break;
          case "oEXPIRED":
            String _oblName_5 = event.getOblName();
            String _plus_10 = ("expire(" + _oblName_5);
            String _plus_11 = (_plus_10 + ")");
            res.append(_plus_11);
            break;
          case "oFULFILLED":
            String _oblName_6 = event.getOblName();
            String _plus_12 = ("fulfill(" + _oblName_6);
            String _plus_13 = (_plus_12 + ")");
            res.append(_plus_13);
            break;
          case "oVIOLATED":
            String _oblName_7 = event.getOblName();
            String _plus_14 = ("violate(" + _oblName_7);
            String _plus_15 = (_plus_14 + ")");
            res.append(_plus_15);
            break;
          case "oTERMINATED":
            String _oblName_8 = event.getOblName();
            String _plus_16 = ("terminate(" + _oblName_8);
            String _plus_17 = (_plus_16 + ")");
            res.append(_plus_17);
            break;
        }
      }
      _xblockexpression = res.append(")");
    }
    return _xblockexpression;
  }
  
  public StringBuilder compileCEvent(final cEvent event, final StringBuilder res, final int d) {
    StringBuilder _xblockexpression = null;
    {
      res.append((("initiates(E" + Integer.valueOf(d)) + ","));
      String _contrEvent = event.getContrEvent();
      if (_contrEvent != null) {
        switch (_contrEvent) {
          case "cACTIVATED":
            String _contrName = event.getContrName();
            String _plus = ("activate(" + _contrName);
            String _plus_1 = (_plus + ")");
            res.append(_plus_1);
            break;
          case "cSUSPENDED":
            String _contrName_1 = event.getContrName();
            String _plus_2 = ("suspend(" + _contrName_1);
            String _plus_3 = (_plus_2 + ")");
            res.append(_plus_3);
            break;
          case "cRESUMED":
            String _contrName_2 = event.getContrName();
            String _plus_4 = ("resume(" + _contrName_2);
            String _plus_5 = (_plus_4 + ")");
            res.append(_plus_5);
            break;
          case "cFULFILLED_ACTIVE_OBLS":
            String _contrName_3 = event.getContrName();
            String _plus_6 = ("fulfill(" + _contrName_3);
            String _plus_7 = (_plus_6 + ")");
            res.append(_plus_7);
            break;
          case "cREVOKED_PARTY":
            String _contrName_4 = event.getContrName();
            String _plus_8 = ("revoke(" + _contrName_4);
            String _plus_9 = (_plus_8 + ")");
            res.append(_plus_9);
            break;
          case "cASSIGNED_PARTY":
            String _contrName_5 = event.getContrName();
            String _plus_10 = ("assignParty(" + _contrName_5);
            String _plus_11 = (_plus_10 + ")");
            res.append(_plus_11);
            break;
          case "cTERMINATED":
            String _contrName_6 = event.getContrName();
            String _plus_12 = ("terminate(" + _contrName_6);
            String _plus_13 = (_plus_12 + ")");
            res.append(_plus_13);
            break;
        }
      }
      _xblockexpression = res.append(")");
    }
    return _xblockexpression;
  }
  
  public StringBuilder compilePEvent(final pEvent event, final StringBuilder res, final int d) {
    StringBuilder _xblockexpression = null;
    {
      res.append((("initiates(E" + Integer.valueOf(d)) + ","));
      String _powEvent = event.getPowEvent();
      if (_powEvent != null) {
        switch (_powEvent) {
          case "pTRIGGERED":
            String _powName = event.getPowName();
            String _plus = ("trigger(" + _powName);
            String _plus_1 = (_plus + ")");
            res.append(_plus_1);
            break;
          case "pACTIVATED":
            String _powName_1 = event.getPowName();
            String _plus_2 = ("activate(" + _powName_1);
            String _plus_3 = (_plus_2 + ")");
            res.append(_plus_3);
            break;
          case "pSUSPENDED":
            String _powName_2 = event.getPowName();
            String _plus_4 = ("suspend(" + _powName_2);
            String _plus_5 = (_plus_4 + ")");
            res.append(_plus_5);
            break;
          case "pRESUMED":
            String _powName_3 = event.getPowName();
            String _plus_6 = ("resume(" + _powName_3);
            String _plus_7 = (_plus_6 + ")");
            res.append(_plus_7);
            break;
          case "pEXERTED":
            String _powName_4 = event.getPowName();
            String _plus_8 = ("exert(" + _powName_4);
            String _plus_9 = (_plus_8 + ")");
            res.append(_plus_9);
            break;
          case "pEXPIRED":
            String _powName_5 = event.getPowName();
            String _plus_10 = ("expire(" + _powName_5);
            String _plus_11 = (_plus_10 + ")");
            res.append(_plus_11);
            break;
          case "pTERMINATED":
            String _powName_6 = event.getPowName();
            String _plus_12 = ("terminate(" + _powName_6);
            String _plus_13 = (_plus_12 + ")");
            res.append(_plus_13);
            break;
        }
      }
      _xblockexpression = res.append(")");
    }
    return _xblockexpression;
  }
  
  public StringBuilder compileInterval(final Interval interval, final StringBuilder res, final int d) {
    StringBuilder _xifexpression = null;
    String _unnamed = interval.getUnnamed();
    boolean _notEquals = (!Objects.equal(_unnamed, null));
    if (_notEquals) {
      _xifexpression = res.append((((("happens(E" + Integer.valueOf(d)) + ",T") + Integer.valueOf(d)) + ")"));
    } else {
      StringBuilder _xifexpression_1 = null;
      IntConst _intConst = interval.getIntConst();
      boolean _notEquals_1 = (!Objects.equal(_intConst, null));
      if (_notEquals_1) {
        _xifexpression_1 = null;
      } else {
        StringBuilder _xifexpression_2 = null;
        SitName _situationName = interval.getSituationName();
        boolean _notEquals_2 = (!Objects.equal(_situationName, null));
        if (_notEquals_2) {
          StringBuilder _xblockexpression = null;
          {
            res.append((("within(E" + Integer.valueOf(d)) + ","));
            this.compileState(interval.getSituationName(), res);
            _xblockexpression = res.append(")");
          }
          _xifexpression_2 = _xblockexpression;
        } else {
          StringBuilder _xblockexpression_1 = null;
          {
            this.compilePoint(interval.getStart(), res, (d + 1));
            res.append(",");
            this.compilePoint(interval.getEnd(), res, (d + 2));
            res.append(",");
            _xblockexpression_1 = res.append(((((("T" + Integer.valueOf((d + 1))) + "<=T") + Integer.valueOf(d)) + "<=T") + Integer.valueOf((d + 2))));
          }
          _xifexpression_2 = _xblockexpression_1;
        }
        _xifexpression_1 = _xifexpression_2;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  public StringBuilder compileState(final SitName state, final StringBuilder res) {
    StringBuilder _xblockexpression = null;
    {
      oState _oState = state.getOState();
      boolean _notEquals = (!Objects.equal(_oState, null));
      if (_notEquals) {
        this.compileOState(state.getOState(), res);
      }
      cState _cState = state.getCState();
      boolean _notEquals_1 = (!Objects.equal(_cState, null));
      if (_notEquals_1) {
        this.compileCState(state.getCState(), res);
      }
      pState _pState = state.getPState();
      boolean _notEquals_2 = (!Objects.equal(_pState, null));
      if (_notEquals_2) {
        this.compilePState(state.getPState(), res);
      }
      StringBuilder _xifexpression = null;
      String _sitName = state.getSitName();
      boolean _notEquals_3 = (!Objects.equal(_sitName, null));
      if (_notEquals_3) {
        String _sitName_1 = state.getSitName();
        String _plus = (_sitName_1 + "(X)");
        _xifexpression = res.append(_plus);
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public StringBuilder compileOState(final oState state, final StringBuilder res) {
    StringBuilder _switchResult = null;
    String _oblState = state.getOblState();
    if (_oblState != null) {
      switch (_oblState) {
        case "oCREATE":
          String _oblName = state.getOblName();
          String _plus = ("create(" + _oblName);
          String _plus_1 = (_plus + ")");
          _switchResult = res.append(_plus_1);
          break;
        case "oINEFFECT":
          String _oblName_1 = state.getOblName();
          String _plus_2 = ("ineffect(" + _oblName_1);
          String _plus_3 = (_plus_2 + ")");
          _switchResult = res.append(_plus_3);
          break;
        case "oSUSPENSION":
          String _oblName_2 = state.getOblName();
          String _plus_4 = ("suspension(" + _oblName_2);
          String _plus_5 = (_plus_4 + ")");
          _switchResult = res.append(_plus_5);
          break;
        case "oSUCCESSFUL_TERMINATION":
          String _oblName_3 = state.getOblName();
          String _plus_6 = ("successfulTermination(" + _oblName_3);
          String _plus_7 = (_plus_6 + ")");
          _switchResult = res.append(_plus_7);
          break;
        case "oUNSUCCESSFUL_TERMINATION":
          String _oblName_4 = state.getOblName();
          String _plus_8 = ("unsuccessfulTermination(" + _oblName_4);
          String _plus_9 = (_plus_8 + ")");
          _switchResult = res.append(_plus_9);
          break;
        case "oVIOLATION":
          String _oblName_5 = state.getOblName();
          String _plus_10 = ("violation(" + _oblName_5);
          String _plus_11 = (_plus_10 + ")");
          _switchResult = res.append(_plus_11);
          break;
        case "oFULFILLMENT":
          String _oblName_6 = state.getOblName();
          String _plus_12 = ("fulfillment(" + _oblName_6);
          String _plus_13 = (_plus_12 + ")");
          _switchResult = res.append(_plus_13);
          break;
        case "oDISCHARGE":
          String _oblName_7 = state.getOblName();
          String _plus_14 = ("discharge(" + _oblName_7);
          String _plus_15 = (_plus_14 + ")");
          _switchResult = res.append(_plus_15);
          break;
      }
    }
    return _switchResult;
  }
  
  public StringBuilder compileCState(final cState state, final StringBuilder res) {
    StringBuilder _switchResult = null;
    String _contrState = state.getContrState();
    if (_contrState != null) {
      switch (_contrState) {
        case "cFORM":
          String _contractName = state.getContractName();
          String _plus = ("form(" + _contractName);
          String _plus_1 = (_plus + ")");
          _switchResult = res.append(_plus_1);
          break;
        case "cINEFFECT":
          String _contractName_1 = state.getContractName();
          String _plus_2 = ("ineffect(" + _contractName_1);
          String _plus_3 = (_plus_2 + ")");
          _switchResult = res.append(_plus_3);
          break;
        case "cSUSPENSION":
          String _contractName_2 = state.getContractName();
          String _plus_4 = ("suspension(" + _contractName_2);
          String _plus_5 = (_plus_4 + ")");
          _switchResult = res.append(_plus_5);
          break;
        case "cSUCCESSFUL_TERMINATION":
          String _contractName_3 = state.getContractName();
          String _plus_6 = ("successfulTermination(" + _contractName_3);
          String _plus_7 = (_plus_6 + ")");
          _switchResult = res.append(_plus_7);
          break;
        case "cUNSECCESSFUL_TERMINATION":
          String _contractName_4 = state.getContractName();
          String _plus_8 = ("unsuccessfulTermination(" + _contractName_4);
          String _plus_9 = (_plus_8 + ")");
          _switchResult = res.append(_plus_9);
          break;
        case "cUNASSIGN":
          String _contractName_5 = state.getContractName();
          String _plus_10 = ("unassign(" + _contractName_5);
          String _plus_11 = (_plus_10 + ")");
          _switchResult = res.append(_plus_11);
          break;
      }
    }
    return _switchResult;
  }
  
  public StringBuilder compilePState(final pState state, final StringBuilder res) {
    StringBuilder _switchResult = null;
    String _powState = state.getPowState();
    if (_powState != null) {
      switch (_powState) {
        case "pCREATE":
          String _powName = state.getPowName();
          String _plus = ("create(" + _powName);
          String _plus_1 = (_plus + ")");
          _switchResult = res.append(_plus_1);
          break;
        case "pINEFFECT":
          String _powName_1 = state.getPowName();
          String _plus_2 = ("ineffect(" + _powName_1);
          String _plus_3 = (_plus_2 + ")");
          _switchResult = res.append(_plus_3);
          break;
        case "pSUSPENSION":
          String _powName_2 = state.getPowName();
          String _plus_4 = ("suspension(" + _powName_2);
          String _plus_5 = (_plus_4 + ")");
          _switchResult = res.append(_plus_5);
          break;
        case "pSUCCESSFUL_TERMINATION":
          String _powName_3 = state.getPowName();
          String _plus_6 = ("successfulTermination(" + _powName_3);
          String _plus_7 = (_plus_6 + ")");
          _switchResult = res.append(_plus_7);
          break;
        case "pUNSUCCESSFUL_TERMINATION":
          String _powName_4 = state.getPowName();
          String _plus_8 = ("unsuccessfulTermination(" + _powName_4);
          String _plus_9 = (_plus_8 + ")");
          _switchResult = res.append(_plus_9);
          break;
      }
    }
    return _switchResult;
  }
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    fsa.generateFile("test.pl", this.compile(IteratorExtensions.<Model>head(Iterators.<Model>filter(resource.getAllContents(), Model.class))));
  }
  
  public String checkParameterType(final EObject bType, final HashMap<String, String> superTypes) {
    if (bType instanceof BasicType) {
      return _checkParameterType((BasicType)bType, superTypes);
    } else if (bType instanceof DomainType) {
      return _checkParameterType((DomainType)bType, superTypes);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(bType, superTypes).toString());
    }
  }
  
  public Object compileDomainConcept(final DomainConcept domainConcept, final StringBuilder res, final HashMap<String, String> superTypes) {
    if (domainConcept instanceof Enumeration) {
      return _compileDomainConcept((Enumeration)domainConcept, res, superTypes);
    } else if (domainConcept instanceof Regular) {
      return _compileDomainConcept((Regular)domainConcept, res, superTypes);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(domainConcept, res, superTypes).toString());
    }
  }
  
  public String compileCType(final CType bType, final String dName, final StringBuilder res, final HashMap<String, String> superTypes) {
    if (bType instanceof BasicType) {
      return _compileCType((BasicType)bType, dName, res, superTypes);
    } else if (bType instanceof DomainType) {
      return _compileCType((DomainType)bType, dName, res, superTypes);
    } else if (bType instanceof OntoCType) {
      return _compileCType((OntoCType)bType, dName, res, superTypes);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(bType, dName, res, superTypes).toString());
    }
  }
}
